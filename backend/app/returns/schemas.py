"""
Pydantic schemas for request/response validation.
"""
from pydantic import BaseModel, Field
from typing import Optional, List
from datetime import datetime


# ==================== Order Schemas ====================

class OrderBase(BaseModel):
    order_id: str
    product_name: str
    product_category: str
    purchase_date: datetime


class OrderCreate(OrderBase):
    customer_id: str = "user_001"
    status: str = "delivered"


class OrderResponse(OrderBase):
    id: int
    customer_id: str
    status: str
    created_at: datetime
    updated_at: datetime

    class Config:
        from_attributes = True


# ==================== Return Schemas ====================

class MediaFile(BaseModel):
    """Media file with base64 data and mime type."""
    data: str = Field(..., description="Base64 encoded image/video data")
    mime_type: str = Field(..., description="MIME type (e.g., image/jpeg, image/png, video/mp4)")
    filename: Optional[str] = Field(None, description="Original filename")


class ReturnCreate(BaseModel):
    order_id: str
    description: str = Field(..., min_length=10, description="Description of the defect")
    damage_type: str = Field(
        ..., 
        pattern="^(PHYSICAL|FUNCTIONAL|COSMETIC|PACKAGING|MISSING_PARTS|WRONG_ITEM|SIZE_ISSUE|COLOR_ISSUE|QUALITY_ISSUE|OTHER)$", 
        description="Type of damage"
    )
    category: str = Field(..., description="Product category")
    
    # Customer contact info (replaces authentication)
    customer_email: Optional[str] = Field(None, description="Customer email for updates")
    customer_phone: Optional[str] = Field(None, description="Customer phone for updates")
    
    media_files: Optional[List[str]] = Field(default=[], description="List of media file names/URLs (legacy)")
    media_base64: Optional[List[MediaFile]] = Field(default=[], description="Base64 encoded media files for GPT-4o Vision analysis")


class ReturnResponse(BaseModel):
    id: int
    order_id: str
    damage_type: str
    description: str
    status: str
    ai_decision: Optional[str] = None
    ai_confidence: Optional[float] = None
    ai_reason: Optional[str] = None
    admin_decision: Optional[str] = None
    admin_note: Optional[str] = None
    media_files: Optional[str] = None
    created_at: datetime
    updated_at: datetime
    
    # Enhanced AI analysis fields
    probable_cause: Optional[str] = None  # "manufacturing", "user_damage", or "uncertain"
    decision_type: Optional[str] = None  # Decision type (APPROVED, REJECTED, ESCALATE_TO_HUMAN, etc.)
    escalation_reason: Optional[str] = None  # Reason for escalation if applicable
    
    # Include order details
    order: Optional[OrderResponse] = None

    class Config:
        from_attributes = True


class ReturnWithOrder(ReturnResponse):
    """Return response with full order details."""
    pass


# ==================== Policy Schemas ====================

class PolicyCreate(BaseModel):
    policy_id: str
    product_category: Optional[str] = None
    title: str
    text: str


class PolicyResponse(BaseModel):
    id: int
    policy_id: str
    product_category: Optional[str]
    title: str
    text: str
    created_at: datetime

    class Config:
        from_attributes = True


# ==================== Admin Schemas ====================

class ManualReviewItem(BaseModel):
    """Summary of a return request pending manual review."""
    return_id: int
    order_id: str
    product_name: str
    product_category: str
    damage_type: str
    description: str
    status: str
    created_at: datetime

    class Config:
        from_attributes = True


class ManualReviewDetail(ReturnResponse):
    """Full details of a return request for admin review."""
    pass


class AdminDecision(BaseModel):
    decision: str = Field(..., pattern="^(APPROVED|REJECTED)$", description="Admin decision")
    note: str = Field(..., min_length=10, description="Note to user explaining the decision")


# ==================== Agent Output Schemas ====================

class VisionAgentOutput(BaseModel):
    """Output from VisionAgent."""
    defect_label: str
    estimated_severity: str  # "minor", "moderate", "severe"
    damage_type: str
    image_description: Optional[str] = None  # Detailed description generated by GPT-4o Vision
    vision_confidence: Optional[float] = None  # Confidence score from GPT-4o Vision (0.0-1.0)
    probable_cause: Optional[str] = None  # "manufacturing", "user_damage", or "uncertain"
    defect_location: Optional[str] = None  # Location of the defect on the product
    damage_pattern_analysis: Optional[str] = None  # Analysis of damage pattern


class PolicyAgentOutput(BaseModel):
    """Output from PolicyAgent."""
    matched_policy_ids: List[str]
    top_policy_texts: List[str]
    raw_cosine_scores: List[float]
    confidence: float  # Decision confidence (NOT similarity) - based on policy interpretation
    policy_interpretation: str
    policy_decision: str = "REJECT"  # "APPROVE" or "REJECT" - what the policy says
    policy_applicability: float = 0.0  # 0.0-1.0 - how well the policy applies to this case


class ResolutionAgentOutput(BaseModel):
    """Output from ResolutionAgent."""
    decision: str  # "APPROVED", "REJECTED", "ESCALATE_TO_HUMAN"
    confidence: float
    reason: str
    decision_type: Optional[str] = None  # Alias for decision, for clarity
    escalation_reason: Optional[str] = None  # Specific reason if escalated


class CommunicationAgentOutput(BaseModel):
    """Output from CommunicationAgent."""
    user_message_title: str
    user_message_body: str


# ==================== Auth Schemas ====================

class LoginRequest(BaseModel):
    username: str
    password: str


class LoginResponse(BaseModel):
    success: bool
    user_type: Optional[str] = None  # "user" or "admin"
    username: Optional[str] = None
    message: Optional[str] = None
